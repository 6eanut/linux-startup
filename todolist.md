2025-11-11

* [ ] 拓展syzlang支持：调研syzlang对riscv的支持现状，明确未覆盖的riscv特有系统调用；
  编写riscv专属syzlang测试描述与用例；
  验证用例在riscv内核的兼容性，提升架构特有代码的覆盖精准度。
* [X] syzkaller在lwn的博客。

2025-11-10

* [X] 关于给配置项清单打分的这个脚本，还需要完善一下，就是列出来那些没有被编进内核的代码是因为什么配置项没满足
  统计一下，因为这些配置项没满足指定值导致多少行代码没有被编译进内核，相应的当前值导致多少行代码被编译进了内核

2025-11-06
~~一些要做的实验：
    1.动态方面：
        现在的kc太臃肿了，在syzkaller的基础上开发rv版本，
        第一个要做的事情是对于每个通过triage且minimize之前的种子，
        分析其系统调用所触发的路径是否在arch/riscv下，如果在，就要把这个系统调用存起来(可以实现一个权重)。~~

 ~~然后添加相应的变异策略和种子生成策略。~~

 ~~2.种子复用方面：
        当linux版本更新后，需要对新的内核做测试。从零开始生成种子去测试太耗费测试资源，可以选择复用上一次测试得到的种子库。
        对种子库进行简化，即只保留那些触发了arch/riscv路径的种子，然后再对这些种子用smt求解器进一步最小化。~~

2025-11-03
~~一些要做的实验：
1.添加riscvsyscall前后，arch/riscv下的代码覆盖比例？这玩意有必要比嘛？还是说只和syzbot比就行了
2.配置项代码覆盖率的事，大概需要五十多个配置项清单。~~

2025-10-31
~~一些问题：
1.目前还没有考虑config在makefile中对文件的影响；
2.配置项间的关系太复杂，后续:
    2-1.需要先对管理了arch/riscv的配置项做一个分类,从功能上
    2-2.对于y/n可以看看能否先打开
    2-3.对于all的不太好处理目前
3.动态验证部分可以把触发到arch/riscv的系统调用加大被选中的概率(这个已经尝试了，看看效果吧)~~

2025-10-30
~~先统计现在的config下，arch/riscv下被配置项包裹的代码有多少，被fuzz覆盖的代码有多少
如果被覆盖的比例远小于被包裹的比例，那就是fuzz的问题
    ->看哪些系统调用能触发arch/riscv下的代码，增大这些系统调用被选中的权重
如果被覆盖的比例和被包裹的比例差不多，那就是config的问题
    ->需要看arch/riscv下的代码被哪些配置项包裹，开启更多的配置项~~

~~1.看哪些系统调用能触发arch/riscv下的代码，增大其权重(动态)
2.看哪些配置项能包裹arch/riscv下的代码，打开它们(静态)~~
