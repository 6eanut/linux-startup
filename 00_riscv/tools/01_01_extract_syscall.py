#!/usr/bin/env python3
import argparse
import os
import re
import shutil
import subprocess
import sys
from collections import defaultdict, deque

EDGE_RE = re.compile(
    r'^\s*"((?:[^"\\]|\\.)*)"\s*->\s*"((?:[^"\\]|\\.)*)"\s*(?:\[\s*label\s*=\s*"((?:[^"\\]|\\.)*)"\s*\])?\s*;\s*$'
)

def unescape_dot_str(s: str) -> str:
    # 输入来自 DOT 的带转义字符串，转换回原始名字
    # 处理 \" 和 \\ 两种常见情况
    return s.replace(r'\"', '"').replace(r'\\', '\\')

def escape_dot_str(s: str) -> str:
    # 输出到 DOT，转义双引号
    return s.replace('"', r'\"')

def parse_edges(dot_text: str):
    edges = []  # list of (caller, callee, label or None)
    for line in dot_text.splitlines():
        m = EDGE_RE.match(line)
        if not m:
            continue
        raw_u, raw_v, raw_label = m.groups()
        u = unescape_dot_str(raw_u)
        v = unescape_dot_str(raw_v)
        label = unescape_dot_str(raw_label) if raw_label is not None else None
        edges.append((u, v, label))
    return edges

def is_syscall_node(name: str, match_substr: str, ignore_case: bool) -> bool:
    if ignore_case:
        return match_substr.lower() in name.lower()
    else:
        return match_substr in name

def build_subgraph_from_syscalls(edges, match_substr="SYSCALL_DEFINE", ignore_case=False):
    # edges: list of (u, v, label)
    # 构建邻接表用于从 syscall 节点向下遍历
    adj = defaultdict(list)
    nodes = set()
    for u, v, lbl in edges:
        adj[u].append((v, lbl))
        nodes.add(u)
        nodes.add(v)

    roots = {n for n in nodes if is_syscall_node(n, match_substr, ignore_case)}
    if not roots:
        return set(), []  # no nodes, no edges

    visited = set()
    q = deque()
    for r in roots:
        visited.add(r)
        q.append(r)

    kept_edges = []  # (u, v, label)
    while q:
        u = q.popleft()
        for v, lbl in adj.get(u, []):
            # 保留边 u -> v
            kept_edges.append((u, v, lbl))
            if v not in visited:
                visited.add(v)
                q.append(v)

    kept_nodes = visited  # 由根可达的所有节点
    return kept_nodes, kept_edges

def render_dot(dot_path: str, out_img: str) -> bool:
    fmt = os.path.splitext(out_img)[1].lstrip(".").lower()
    if not fmt:
        fmt = "png"
        out_img = out_img + ".png"
    if shutil.which("dot") is None:
        print(f"[WARN] Graphviz 'dot' not found. Skipping image rendering. You can run: dot -T{fmt} {dot_path} -o {out_img}")
        return False
    cmd = ["dot", f"-T{fmt}", dot_path, "-o", out_img]
    try:
        subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        print(f"[INFO] Wrote image: {out_img}")
        return True
    except subprocess.CalledProcessError as e:
        print(f"[ERROR] dot failed: {' '.join(cmd)}\nstderr:\n{e.stderr}")
        return False

def write_subgraph_dot(nodes, edges, out_path, match_substr="SYSCALL_DEFINE", ignore_case=False):
    def is_syscall(n: str) -> bool:
        return is_syscall_node(n, match_substr, ignore_case)

    lines = []
    lines.append("digraph SyscallSubgraph {")
    lines.append("  rankdir=TB;")
    lines.append("  node [fontname=Helvetica];")
    lines.append("  edge [fontname=Helvetica, arrowsize=0.7];")

    # 节点样式：SYSCALL_DEFINE 节点双圆+蓝色填充，其余为普通椭圆
    for n in sorted(nodes):
        safe = escape_dot_str(n)
        if is_syscall(n):
            lines.append(f'  "{safe}" [shape=doublecircle, style=filled, fillcolor=lightskyblue, color=blue];')
        else:
            lines.append(f'  "{safe}" [shape=ellipse];')

    # 边，保留 label（如果有）
    for u, v, lbl in edges:
        su = escape_dot_str(u)
        sv = escape_dot_str(v)
        if lbl is not None and lbl != "":
            sl = escape_dot_str(lbl)
            lines.append(f'  "{su}" -> "{sv}" [label="{sl}"];')
        else:
            lines.append(f'  "{su}" -> "{sv}";')

    lines.append("}")

    with open(out_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))
    print(f"[INFO] Wrote DOT: {out_path}")

def main():
    ap = argparse.ArgumentParser(description="Extract subgraph from callgraph.dot starting at SYSCALL_DEFINE* and going downward (caller -> callee).")
    ap.add_argument("-i", "--input", required=True, help="Input DOT file (generated by the existing tool).")
    ap.add_argument("-o", "--output-dot", required=True, help="Output DOT path for the syscall-only subgraph.")
    ap.add_argument("-p", "--output-img", help="Output image path (PNG/SVG/PDF determined by extension).")
    ap.add_argument("--match", default="SYSCALL_DEFINE", help="Substring to identify syscall macro nodes. Default: SYSCALL_DEFINE")
    ap.add_argument("--ignore-case", action="store_true", help="Case-insensitive matching for --match.")
    args = ap.parse_args()

    with open(args.input, "r", encoding="utf-8") as f:
        dot_text = f.read()

    edges = parse_edges(dot_text)
    if not edges:
        print("[ERROR] No edges parsed from DOT. Ensure the input is produced by the given generator.")
        sys.exit(1)

    kept_nodes, kept_edges = build_subgraph_from_syscalls(
        edges,
        match_substr=args.match,
        ignore_case=args.ignore_case,
    )

    if not kept_nodes:
        print("[WARN] No nodes matched the given --match and reachable subgraph is empty.")
    write_subgraph_dot(
        kept_nodes,
        kept_edges,
        args.output_dot,
        match_substr=args.match,
        ignore_case=args.ignore_case,
    )

    if args.output_img:
        render_dot(args.output_dot, args.output_img)

if __name__ == "__main__":
    main()

# 使用方式示例

# 仅保留从 SYSCALL_DEFINE* 开始向下可达的部分：
# python3 extract_syscall_subgraph.py -i out/callgraph.dot -o out/syscalls.dot -p out/syscalls.png
# 自定义匹配子串（默认 "SYSCALL_DEFINE"），支持大小写不敏感匹配：
# python3 extract_syscall_subgraph.py -i callgraph.dot -o syscalls.dot -p syscalls.png --match 'compat_syscall_define' --ignore-case